{
  "version": 3,
  "sources": ["../node_modules/@noble/hashes/src/_assert.ts", "../node_modules/@noble/hashes/src/crypto.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/_md.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../node_modules/@noble/hashes/src/_u64.ts", "../node_modules/@noble/hashes/src/sha512.ts", "../node_modules/@noble/curves/src/abstract/utils.ts", "../node_modules/@noble/curves/src/abstract/modular.ts", "../node_modules/@noble/curves/src/abstract/curve.ts", "../node_modules/@noble/curves/src/abstract/edwards.ts", "../node_modules/@noble/curves/src/abstract/montgomery.ts", "../node_modules/@noble/curves/src/ed25519.ts", "../node_modules/@noble/hashes/src/ripemd160.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/hashes/src/hkdf.ts", "../node_modules/@noble/ciphers/src/_assert.ts", "../node_modules/@noble/ciphers/src/utils.ts", "../node_modules/@noble/ciphers/src/_polyval.ts", "../node_modules/@noble/ciphers/src/aes.ts", "../node_modules/@noble/ciphers/src/crypto.ts", "../node_modules/@noble/ciphers/src/webcrypto.ts", "../node_modules/cbor-x/decode.js", "../node_modules/cbor-x/encode.js", "../src/suite25519.js"],
  "sourcesContent": ["/**\n * Internal assertion helpers.\n * @module\n */\n\n/** Asserts something is positive integer. */\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Hash interface. */\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Asserts something is hash */\nfunction ahash(h: Hash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, abytes, ahash, aexists, aoutput };\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.ts';\n// export { isBytes } from './_assert.ts';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n// Cast array to view\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): void {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean =\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash function */\nexport type CHash = ReturnType<typeof wrapConstructor>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof wrapConstructorWithOpts>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof wrapXOFConstructorWithOpts>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function wrapConstructor<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { aexists, aoutput } from './_assert.ts';\nimport { type Input, Hash, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, rotr, wrapConstructor } from './utils.ts';\n\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    SHA256_W.fill(0);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n  protected A = 0xc1059ed8 | 0;\n  protected B = 0x367cd507 | 0;\n  protected C = 0x3070dd17 | 0;\n  protected D = 0xf70e5939 | 0;\n  protected E = 0xffc00b31 | 0;\n  protected F = 0x68581511 | 0;\n  protected G = 0x64f98fa7 | 0;\n  protected H = 0xbefa4fa4 | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n/** SHA2-256 hash function */\nexport const sha256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n */\nimport { HashMD } from './_md.ts';\nimport u64 from './_u64.ts';\nimport { type CHash, wrapConstructor } from './utils.ts';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0x6a09e667 | 0;\n  protected Al: number = 0xf3bcc908 | 0;\n  protected Bh: number = 0xbb67ae85 | 0;\n  protected Bl: number = 0x84caa73b | 0;\n  protected Ch: number = 0x3c6ef372 | 0;\n  protected Cl: number = 0xfe94f82b | 0;\n  protected Dh: number = 0xa54ff53a | 0;\n  protected Dl: number = 0x5f1d36f1 | 0;\n  protected Eh: number = 0x510e527f | 0;\n  protected El: number = 0xade682d1 | 0;\n  protected Fh: number = 0x9b05688c | 0;\n  protected Fl: number = 0x2b3e6c1f | 0;\n  protected Gh: number = 0x1f83d9ab | 0;\n  protected Gl: number = 0xfb41bd6b | 0;\n  protected Hh: number = 0x5be0cd19 | 0;\n  protected Hl: number = 0x137e2179 | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy(): void {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0x8c3d37c8 | 0;\n  protected Al: number = 0x19544da2 | 0;\n  protected Bh: number = 0x73e19966 | 0;\n  protected Bl: number = 0x89dcd4d6 | 0;\n  protected Ch: number = 0x1dfab7ae | 0;\n  protected Cl: number = 0x32ff9c82 | 0;\n  protected Dh: number = 0x679dd514 | 0;\n  protected Dl: number = 0x582f9fcf | 0;\n  protected Eh: number = 0x0f6d2b69 | 0;\n  protected El: number = 0x7bd44da8 | 0;\n  protected Fh: number = 0x77e36f73 | 0;\n  protected Fl: number = 0x04c48942 | 0;\n  protected Gh: number = 0x3f9d85a8 | 0;\n  protected Gl: number = 0x6a1d36c8 | 0;\n  protected Hh: number = 0x1112e6ad | 0;\n  protected Hl: number = 0x91d692a1 | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0x22312194 | 0;\n  protected Al: number = 0xfc2bf72c | 0;\n  protected Bh: number = 0x9f555fa3 | 0;\n  protected Bl: number = 0xc84c64c2 | 0;\n  protected Ch: number = 0x2393b86b | 0;\n  protected Cl: number = 0x6f53b151 | 0;\n  protected Dh: number = 0x96387719 | 0;\n  protected Dl: number = 0x5940eabd | 0;\n  protected Eh: number = 0x96283ee2 | 0;\n  protected El: number = 0xa88effe3 | 0;\n  protected Fh: number = 0xbe5e1e25 | 0;\n  protected Fl: number = 0x53863992 | 0;\n  protected Gh: number = 0x2b0199fc | 0;\n  protected Gl: number = 0x2c85b8aa | 0;\n  protected Hh: number = 0x0eb72ddc | 0;\n  protected Hl: number = 0x81c52ca2 | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0xcbbb9d5d | 0;\n  protected Al: number = 0xc1059ed8 | 0;\n  protected Bh: number = 0x629a292a | 0;\n  protected Bl: number = 0x367cd507 | 0;\n  protected Ch: number = 0x9159015a | 0;\n  protected Cl: number = 0x3070dd17 | 0;\n  protected Dh: number = 0x152fecd8 | 0;\n  protected Dl: number = 0xf70e5939 | 0;\n  protected Eh: number = 0x67332667 | 0;\n  protected El: number = 0xffc00b31 | 0;\n  protected Fh: number = 0x8eb44a87 | 0;\n  protected Fl: number = 0x68581511 | 0;\n  protected Gh: number = 0xdb0c2e0d | 0;\n  protected Gl: number = 0x64f98fa7 | 0;\n  protected Hh: number = 0x47b5481d | 0;\n  protected Hl: number = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/** SHA2-512 hash function. */\nexport const sha512: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA512());\n/** SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\n/** SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\n/** SHA2-384 hash function. */\nexport const sha384: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean =\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\nconst u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr: ArrayLike<number>) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n", "/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n =/* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) \u2261 1    if a is a square (mod p)\n  // (a | p) \u2261 -1   if a is not a square (mod p)\n  // (a | p) \u2261 0    if a \u2261 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) \u2261 -1 and set c \u2261 zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n    // Crash instead of infinity loop, we cannot reasonable count until P.\n    if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n  }\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be \u2261 -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P \u2261 3 (mod 4)\n * 2. P \u2261 5 (mod 8)\n * 3. P \u2261 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P \u2261 3 (mod 4)\n  // \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q \u2261 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P \u2261 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * * (a | p) \u2261 1    if a is a square (mod p), quadratic residue\n * * (a | p) \u2261 -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) \u2261 0    if a \u2261 0 (mod p)\n */\nexport function FpLegendre(order: bigint): <T>(f: IField<T>, x: T) => T {\n  const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n  return <T>(f: IField<T>, x: T): T => f.pow(x, legendreConst);\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>): (x: T) => boolean {\n  const legendre = FpLegendre(f.ORDER);\n  return (x: T): boolean => {\n    const p = legendre(f, x);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(\n  n: bigint,\n  nBitLength?: number\n): {\n  nBitLength: number;\n  nByteLength: number;\n} {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      redef.sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type IField, nLength, validateField } from './modular.ts';\nimport { bitLen, bitMask, validateObject } from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nfunction constTimeNegate<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\nexport type WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\nexport type IWNAF<T extends Group<T>> = {\n  constTimeNegate: <T extends Group<T>>(condition: boolean, item: T) => T;\n  hasPrecomputes(elm: T): boolean;\n  unsafeLadder(elm: T, n: bigint, p?: T): T;\n  precomputeWindow(elm: T, W: number): Group<T>[];\n  wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T };\n  wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc?: T): T;\n  getPrecomputes(W: number, P: T, transform: Mapper<T>): T[];\n  wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T };\n  wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T;\n  setWindowSize(P: T, W: number): void;\n};\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number): IWNAF<T> {\n  return {\n    constTimeNegate,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n     * - \uD835\uDC4A is the window size\n     * - \uD835\uDC5B is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // i=1, bc we skip 0\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // Smaller version:\n      // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n      // TODO: check the scalar is less than group order?\n      // wNAF behavior is undefined otherwise. But have to carefully remove\n      // other checks before wNAF. ORDER == bits here.\n      // Accumulators\n      let p = c.ZERO;\n      let f = c.BASE;\n      // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n      // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n      // there is negate now: it is possible that negated element from low value\n      // would be the same as high element, which will create carry into next window.\n      // It's not obvious how this can fail, but still worth investigating later.\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // bits are 0: add garbage to fake point\n          // Important part for const-time getPublicKey: add random \"noise\" point to f.\n          f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n        } else {\n          // bits are 1: add to result point\n          p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n        }\n      }\n      // Return both real and fake points: JIT won't eliminate f.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        if (n === _0n) break; // Early-exit, skip 0 value\n        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // Window bits are 0: skip processing.\n          // Move to next window.\n          continue;\n        } else {\n          const item = precomputes[offset];\n          acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n        }\n      }\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length)\n    throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n): (scalars: bigint[]) => T {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar \u00D7 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 \u00D7 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 \u00D7 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2.\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  type AffinePoint,\n  type BasicCurve,\n  type Group,\n  type GroupConstructor,\n  pippenger,\n  validateBasic,\n  wNAF,\n} from './curve.ts';\nimport { Field, mod } from './modular.ts';\n// prettier-ignore\nimport {\n  abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes,\n  ensureBytes, type FHash, type Hex, memoized, numberToBytesLE, validateObject\n} from './utils.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio \u221A(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & { nByteLength: number; nBitLength: number }>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType): CurveTypeWithLength {\n  const opts = validateBasic(curve);\n  validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX\u00B2 + Y\u00B2)Z\u00B2 = Z\u2074 + dX\u00B2Y\u00B2\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X\u00B2\n    const Y2 = modP(Y * Y); // Y\u00B2\n    const Z2 = modP(Z * Z); // Z\u00B2\n    const Z4 = modP(Z2 * Z2); // Z\u2074\n    const aX2 = modP(X2 * a); // aX\u00B2\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX\u00B2 + Y\u00B2)Z\u00B2\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z\u2074 + dX\u00B2Y\u00B2\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (x, y, z, t) \u220B (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x\u00B2 = (y\u00B2-1)/(dy\u00B2+1) mod p. Ed448: x\u00B2 = (y\u00B2-1)/(dy\u00B2-1) mod p. Generic case:\n      // ax\u00B2+y\u00B2=1+dx\u00B2y\u00B2 => y\u00B2-1=dx\u00B2y\u00B2-ax\u00B2 => y\u00B2-1=x\u00B2(dy\u00B2-a) => x\u00B2=(y\u00B2-1)/(dy\u00B2-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y\u00B2 - 1\n      const v = modP(d * y2 - a); // v = d y\u00B2 + 1.\n      let { isValid, value: x } = uvRatio(u, v); // \u221A(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex): Point {\n      const { scalar } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.ts';\nimport {\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  nByteLength: number;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  a: bigint;\n  montgomeryBits: number;\n  powPminus2?: (x: bigint) => bigint;\n  xyToU?: (x: bigint, y: bigint) => bigint;\n  Gu: bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(\n    curve,\n    {\n      a: 'bigint',\n    },\n    {\n      montgomeryBits: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      powPminus2: 'function',\n      Gu: 'bigint',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...curve } as const);\n}\n\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P } = CURVE;\n  const modP = (n: bigint) => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\n\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, _0n, P);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw: [bigint, bigint];\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n\n  function encodeUCoordinate(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n\n  function decodeUCoordinate(uEnc: Hex): bigint {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n: Hex): bigint {\n    const bytes = ensureBytes('scalar', n);\n    const len = bytes.length;\n    if (len !== montgomeryBytes && len !== fieldLen) {\n      let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n      throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n    }\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\n    GuBytes: GuBytes,\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { type AffinePoint, type Group, pippenger } from './abstract/curve.ts';\nimport { type CurveFn, type ExtPointType, twistedEdwards } from './abstract/edwards.ts';\nimport {\n  createHasher,\n  expand_message_xmd,\n  type htfBasicOpts,\n  type HTFMethod,\n} from './abstract/hash-to-curve.ts';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.ts';\nimport { montgomery, type CurveFn as XCurveFn } from './abstract/montgomery.ts';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  type Hex,\n  numberToBytesLE,\n} from './abstract/utils.ts';\n\n// 2n**255n - 19n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v\u00B3\n  const v7 = mod(v3 * v3 * v, P); // v\u2077\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv\u00B3)(uv\u2077)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\u00B2\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx\u00B2 = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx\u00B2 = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx\u00B2 = -u\u221A(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n/** Weird / bogus points, useful for debugging. */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() =>\n  ({\n    // Removing Fp.create() will still work, and is 10% faster on sign\n    a: Fp.create(BigInt(-1)),\n    // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 2n**255n - 19n\n    Fp,\n    // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    h: _8n,\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/\u221Av\n    uvRatio,\n  }) as const)();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\n  const inv = Fp.invertBatch([xd, yd]); // batch division\n  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.encodeToCurve)();\n\nfunction aristp(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// \u221A(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / \u221A(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\u00B2\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\u00B2\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/\u221A(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  private readonly ep: ExtendedPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(ep: ExtendedPoint) {\n    this.ep = ep;\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): RistPoint {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * https://ristretto.group/formulas/elligator.html\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * https://ristretto.group/formulas/decoding.html\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  static msm(points: RistPoint[], scalars: bigint[]): RistPoint {\n    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n    return pippenger(RistPoint, Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * https://ristretto.group/formulas/encoding.html\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  // Compare one point to another.\n  equals(other: RistPoint): boolean {\n    aristp(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\nexport const RistrettoPoint: typeof RistPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts): RistPoint => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\n/** @deprecated */\nexport const hash_to_ristretto255: (msg: Uint8Array, options: htfBasicOpts) => RistPoint =\n  hashToRistretto255; // legacy\n", "/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n */\nimport { HashMD } from './_md.ts';\nimport { rotl, wrapConstructor, type CHash } from './utils.ts';\n\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));\n\nconst shifts = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  else if (group === 1) return (x & y) | (~x & z);\n  else if (group === 2) return (x | ~y) ^ z;\n  else if (group === 3) return (x & z) | (y & ~z);\n  else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst R_BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) R_BUF[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    R_BUF.fill(0);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/** RIPEMD-160 - a legacy hash function from 1990s. */\nexport const ripemd160: CHash = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash } from './_assert.ts';\nimport { Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/**\n * HKDF (RFC 5869): extract + expand in one step.\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n * @module\n */\nimport { ahash, anumber } from './_assert.ts';\nimport { hmac } from './hmac.ts';\nimport { type CHash, type Input, toBytes } from './utils.ts';\n\n/**\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input): Uint8Array {\n  ahash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen);\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n\n/**\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n * @param hash - hash function that would be used (e.g. sha256)\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32): Uint8Array {\n  ahash(hash);\n  anumber(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * import { hkdf } from '@noble/hashes/hkdf';\n * import { sha256 } from '@noble/hashes/sha2';\n * import { randomBytes } from '@noble/hashes/utils';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n): Uint8Array => expand(hash, extract(hash, ikm, salt), info, length);\n", "/**\n * Internal assertion helpers.\n * @module\n */\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nfunction abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\nexport { abool, abytes, aexists, ahash, anumber, aoutput, isBytes };\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nimport { abytes, isBytes } from './_assert.js';\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray): Uint8Array =>\n  new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray): Uint32Array =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray): DataView =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE: boolean = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = copyBytes(data);\n  else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps (will corrupt and break if input and output same)\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // probably will fail with some obscure proxies, but this is best we can do\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n// Params is outside return type, so it is accessible before calling constructor\n// If function support multiple nonceLength's, we return best one\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key);\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);\n      else abytes(nonce, params.nonceLength);\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\n// Polyfill for Safari 14\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(ciphertext: Uint8Array, AAD?: Uint8Array): Uint8Array {\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n  setBigUint64(view, 8, BigInt(ciphertext.length), true);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n", "/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\nimport { abytes, aexists, aoutput } from './_assert.js';\nimport { clean, copyBytes, createView, Hash, type Input, toBytes, u32 } from './utils.js';\n\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0: number, s1: number, s2: number, s3: number) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: (s2 << 31) | (s3 >>> 1),\n    s2: (s1 << 31) | (s2 >>> 1),\n    s1: (s0 << 31) | (s1 >>> 1),\n    s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n  };\n};\n\nconst swapLE = (n: number) =>\n  (((n >>> 0) & 0xff) << 24) |\n  (((n >>> 8) & 0xff) << 16) |\n  (((n >>> 16) & 0xff) << 8) |\n  ((n >>> 24) & 0xff) |\n  0;\n\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k: Uint8Array): Uint8Array {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = (t >>> 1) | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\n\ntype Value = { s0: number; s1: number; s2: number; s3: number };\n\nconst estimateWindow = (bytes: number) => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\n\nclass GHASH implements Hash<GHASH> {\n  readonly blockLen = BLOCK_SIZE;\n  readonly outputLen = BLOCK_SIZE;\n  protected s0 = 0;\n  protected s1 = 0;\n  protected s2 = 0;\n  protected s3 = 0;\n  protected finished = false;\n  protected t: Value[];\n  private W: number;\n  private windowSize: number;\n  // We select bits per window adaptively based on expectedLength\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles: Value[] = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W))\n      throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = (this.windowSize = 2 ** W);\n    const items: Value[] = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = (byte >>> (W - j - 1)) & 1;\n          if (!bit) continue;\n          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n          (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n        }\n        items.push({ s0, s1, s2, s3 });\n      }\n    }\n    this.t = items;\n  }\n  protected _updateBlock(s0: number, s1: number, s2: number, s3: number) {\n    (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n    const { W, t, windowSize } = this;\n    // prettier-ignore\n    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = (num >>> (8 * bytePos)) & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = (byte >>> (W * bitPos)) & mask;\n          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n          (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      clean(ZEROS32); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const { t } = this;\n    // clean precompute table\n    for (const elm of t) {\n      (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n    }\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest(): Uint8Array {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\n\nclass Polyval extends GHASH {\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    const ghKey = _toGHASHKey(copyBytes(key));\n    super(ghKey, expectedLength);\n    clean(ghKey);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(\n        swapLE(b32[i * 4 + 3]),\n        swapLE(b32[i * 4 + 2]),\n        swapLE(b32[i * 4 + 1]),\n        swapLE(b32[i * 4 + 0])\n      );\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(\n        swapLE(ZEROS32[3]),\n        swapLE(ZEROS32[2]),\n        swapLE(ZEROS32[1]),\n        swapLE(ZEROS32[0])\n      );\n      clean(ZEROS32);\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\n\nexport type CHashPV = ReturnType<typeof wrapConstructorWithKey>;\nfunction wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input, expectedLength?: number) => Hash<H>\n): {\n  (msg: Input, key: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Input, expectedLength?: number): Hash<H>;\n} {\n  const hashC = (msg: Input, key: Input): Uint8Array =>\n    hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input, expectedLength?: number) => hashCons(key, expectedLength);\n  return hashC;\n}\n\n/** GHash MAC for AES-GCM. */\nexport const ghash: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new GHASH(key, expectedLength)\n);\n\n/** Polyval MAC for AES-SIV. */\nexport const polyval: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new Polyval(key, expectedLength)\n);\n", "/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { abytes } from './_assert.js';\nimport { ghash, polyval } from './_polyval.js';\nimport {\n  type Cipher,\n  type CipherWithOutput,\n  clean,\n  complexOverlapBytes,\n  concatBytes,\n  copyBytes,\n  createView,\n  equalBytes,\n  getOutput,\n  isAligned32,\n  overlapBytes,\n  setBigUint64,\n  u32,\n  u8,\n  wrapCipher,\n} from './utils.js';\n\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\n// TODO: remove multiplication, binary ops only\nfunction mul2(n: number) {\n  return (n << 1) ^ (POLY & -(n >> 7));\n}\n\nfunction mul(a: number, b: number) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n  const t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n  }\n  clean(t);\n  return box;\n})();\n\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\n// Rotate u32 by 8\nconst rotr32_8 = (n: number) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n: number) => (n << 8) | (n >>> 24);\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox: Uint8Array, fn: (n: number) => number) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = (sbox[i] << 8) | sbox[j];\n    }\n  }\n  return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\n\nconst tableEncoding = /* @__PURE__ */ genTtable(\n  sbox,\n  (s: number) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2)\n);\nconst tableDecoding = /* @__PURE__ */ genTtable(\n  invSbox,\n  (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14)\n);\n\nconst xPowers = /* @__PURE__ */ (() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key: Uint8Array): Uint32Array {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len))\n    throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n  const { sbox2 } = tableEncoding;\n  const toClean = [];\n  if (!isAligned32(key)) toClean.push((key = copyBytes(key)));\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = (n: number) => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n    else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  clean(...toClean);\n  return xk;\n}\n\nfunction expandKeyDecLE(key: Uint8Array): Uint32Array {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const { sbox2 } = tableEncoding;\n  const { T0, T1, T2, T3 } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  clean(encKey);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n\n// Apply tables\nfunction apply0123(\n  T01: Uint32Array,\n  T23: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n) {\n  return (\n    T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n    T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]\n  );\n}\n\nfunction applySbox(sbox2: Uint16Array, s0: number, s1: number, s2: number, s3: number) {\n  return (\n    sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n    (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16)\n  );\n}\n\nfunction encrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): { s0: number; s1: number; s2: number; s3: number } {\n  const { sbox2, T01, T23 } = tableEncoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): {\n  s0: number;\n  s1: number;\n  s2: number;\n  s3: number;\n} {\n  const { sbox2, T01, T23 } = tableDecoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // Last round\n  const t0: number = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1: number = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2: number = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3: number = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// TODO: investigate merging with ctr32\nfunction ctrCounter(\n  xk: Uint32Array,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getOutput(srcLen, dst);\n  complexOverlapBytes(src, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = (carry + (ctr[i] & 0xff)) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(\n  xk: Uint32Array,\n  isLE: boolean,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getOutput(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr: ((key: Uint8Array, nonce: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aesctr(key: Uint8Array, nonce: Uint8Array): CipherWithOutput {\n    function processCtr(buf: Uint8Array, dst?: Uint8Array) {\n      abytes(buf);\n      if (dst !== undefined) {\n        abytes(dst);\n        if (!isAligned32(dst)) throw new Error('unaligned destination');\n      }\n      const xk = expandKeyLE(key);\n      const n = copyBytes(nonce); // align + avoid changing\n      const toClean = [xk, n];\n      if (!isAligned32(buf)) toClean.push((buf = copyBytes(buf)));\n      const out = ctrCounter(xk, n, buf, dst);\n      clean(...toClean);\n      return out;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCtr(plaintext, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCtr(ciphertext, dst),\n    };\n  }\n);\n\nfunction validateBlockDecrypt(data: Uint8Array) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error(\n      'aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE\n    );\n  }\n}\n\nfunction validateBlockEncrypt(plaintext: Uint8Array, pcks5: boolean, dst?: Uint8Array) {\n  abytes(plaintext);\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0)\n    throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  if (!isAligned32(plaintext)) plaintext = copyBytes(plaintext);\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  dst = getOutput(outLen, dst);\n  complexOverlapBytes(plaintext, dst);\n  const o = u32(dst);\n  return { b, o, out: dst };\n}\n\nfunction validatePCKS(data: Uint8Array, pcks5: boolean) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error('aes/pcks5: empty ciphertext not allowed');\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error('aes/pcks5: wrong padding');\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++)\n    if (data[len - i - 1] !== lastByte) throw new Error('aes/pcks5: wrong padding');\n  return out;\n}\n\nfunction padPCKS(left: Uint8Array) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n\n/** Options for ECB and CBC. */\nexport type BlockOpts = { disablePadding?: boolean };\n\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb: ((key: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16 },\n  function aesecb(key: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const xk = expandKeyLE(key);\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(xk);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        dst = getOutput(ciphertext.length, dst);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        for (let i = 0; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round\u2019s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc: ((key: Uint8Array, iv: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescbc(key: Uint8Array, iv: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const xk = expandKeyLE(key);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        dst = getOutput(ciphertext.length, dst);\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= b.length; ) {\n          // prettier-ignore\n          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n          (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n          (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb: ((key: Uint8Array, iv: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescfb(key: Uint8Array, iv: Uint8Array): CipherWithOutput {\n    function processCfb(src: Uint8Array, isEncrypt: boolean, dst?: Uint8Array) {\n      abytes(src);\n      const srcLen = src.length;\n      dst = getOutput(srcLen, dst);\n      if (overlapBytes(src, dst)) throw new Error('overlapping src and dst not supported.');\n      const xk = expandKeyLE(key);\n      let _iv = iv;\n      const toClean: (Uint8Array | Uint32Array)[] = [xk];\n      if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n      if (!isAligned32(src)) toClean.push((src = copyBytes(src)));\n      const src32 = u32(src);\n      const dst32 = u32(dst);\n      const next32 = isEncrypt ? dst32 : src32;\n      const n32 = u32(_iv);\n      // prettier-ignore\n      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n      for (let i = 0; i + 4 <= src32.length; ) {\n        const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n        dst32[i + 0] = src32[i + 0] ^ e0;\n        dst32[i + 1] = src32[i + 1] ^ e1;\n        dst32[i + 2] = src32[i + 2] ^ e2;\n        dst32[i + 3] = src32[i + 3] ^ e3;\n        (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n      }\n      // leftovers (less than block)\n      const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n      if (start < srcLen) {\n        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n        const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n        for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n        clean(buf);\n      }\n      clean(...toClean);\n      return dst;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCfb(plaintext, true, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCfb(ciphertext, false, dst),\n    };\n  }\n);\n\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(\n  fn: typeof ghash,\n  isLE: boolean,\n  key: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) {\n  const aadLength = AAD == null ? 0 : AAD.length;\n  const h = fn.create(key, data.length + aadLength);\n  if (AAD) h.update(AAD);\n  h.update(data);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  if (AAD) setBigUint64(view, 0, BigInt(aadLength * 8), isLE);\n  setBigUint64(view, 8, BigInt(data.length * 8), isLE);\n  h.update(num);\n  const res = h.digest();\n  clean(num);\n  return res;\n}\n\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aesgcm(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    // NIST 800-38d doesn't enforce minimum nonce length.\n    // We enforce 8 bytes for compat with openssl.\n    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n    if (nonce.length < 8) throw new Error('aes/gcm: invalid nonce length');\n    const tagLength = 16;\n    function _computeTag(authKey: Uint8Array, tagMask: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(ghash, false, authKey, data, AAD);\n      for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n      return tag;\n    }\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const authKey = EMPTY_BLOCK.slice();\n      const counter = EMPTY_BLOCK.slice();\n      ctr32(xk, false, counter, counter, authKey);\n      // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n      if (nonce.length === 12) {\n        counter.set(nonce);\n      } else {\n        const nonceLen = EMPTY_BLOCK.slice();\n        const view = createView(nonceLen);\n        setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n        // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n        const g = ghash.create(authKey).update(nonce).update(nonceLen);\n        g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n        g.destroy();\n      }\n      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n      return { xk, authKey, counter, tagMask };\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const out = new Uint8Array(plaintext.length + tagLength);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, counter, tagMask];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n        toClean.push(tag);\n        out.set(tag, plaintext.length);\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, tagMask, counter];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = _computeTag(authKey, tagMask, data);\n        toClean.push(tag);\n        if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n        const out = ctr32(xk, false, counter, data);\n        clean(...toClean);\n        return out;\n      },\n    };\n  }\n);\n\nconst limit = (name: string, min: number, max: number) => (value: number) => {\n  if (!Number.isSafeInteger(value) || min > value || value > max) {\n    const minmax = '[' + min + '..' + max + ']';\n    throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n  }\n};\n\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const siv: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aessiv(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(key, 16, 24, 32);\n    NONCE_LIMIT(nonce.length);\n    if (AAD !== undefined) AAD_LIMIT(AAD.length);\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const encKey = new Uint8Array(key.length);\n      const authKey = new Uint8Array(16);\n      const toClean: (Uint8Array | Uint32Array)[] = [xk, encKey];\n      let _nonce = nonce;\n      if (!isAligned32(_nonce)) toClean.push((_nonce = copyBytes(_nonce)));\n      const n32 = u32(_nonce);\n      // prettier-ignore\n      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n      let counter = 0;\n      for (const derivedKey of [authKey, encKey].map(u32)) {\n        const d32 = u32(derivedKey);\n        for (let i = 0; i < d32.length; i += 2) {\n          // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n          d32[i + 0] = o0;\n          d32[i + 1] = o1;\n          s0 = ++counter; // increment counter inside state\n        }\n      }\n      const res = { authKey, encKey: expandKeyLE(encKey) };\n      // Cleanup\n      clean(...toClean);\n      return res;\n    }\n    function _computeTag(encKey: Uint32Array, authKey: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(polyval, true, authKey, data, AAD);\n      // Compute the expected tag by XORing S_s and the nonce, clearing the\n      // most significant bit of the last byte and encrypting with the\n      // message-encryption key.\n      for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n      tag[15] &= 0x7f; // Clear the highest bit\n      // encrypt tag as block\n      const t32 = u32(tag);\n      // prettier-ignore\n      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n      (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n      return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey: Uint32Array, tag: Uint8Array, input: Uint8Array) {\n      let block = copyBytes(tag);\n      block[15] |= 0x80; // Force highest bit\n      const res = ctr32(encKey, true, block, input);\n      // Cleanup\n      clean(block);\n      return res;\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        PLAIN_LIMIT(plaintext.length);\n        const { encKey, authKey } = deriveKeys();\n        const tag = _computeTag(encKey, authKey, plaintext);\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey, tag];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        const out = new Uint8Array(plaintext.length + tagLength);\n        out.set(tag, plaintext.length);\n        out.set(processSiv(encKey, tag, plaintext));\n        // Cleanup\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        CIPHER_LIMIT(ciphertext.length);\n        const tag = ciphertext.subarray(-tagLength);\n        const { encKey, authKey } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n        const expectedTag = _computeTag(encKey, authKey, plaintext);\n        toClean.push(expectedTag);\n        if (!equalBytes(tag, expectedTag)) {\n          clean(...toClean);\n          throw new Error('invalid polyval tag');\n        }\n        // Cleanup\n        clean(...toClean);\n        return plaintext;\n      },\n    };\n  }\n);\n\nfunction isBytes32(a: unknown): a is Uint32Array {\n  return (\n    a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array')\n  );\n}\n\nfunction encryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\nfunction decryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n  /*\n  High-level pseudocode:\n  ```\n  A: u64 = IV\n  out = []\n  for (let i=0, ctr = 0; i<6; i++) {\n    for (const chunk of chunks(plaintext, 8)) {\n      A ^= swapEndianess(ctr++)\n      [A, res] = chunks(encrypt(A || chunk), 8);\n      out ||= res\n    }\n  }\n  out = A || out\n  ```\n  Decrypt is the same, but reversed.\n  */\n  encrypt(kek: Uint8Array, out: Uint8Array) {\n    // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n    // If you need it larger, open an issue.\n    if (out.length >= 2 ** 32) throw new Error('plaintext should be less than 4gb');\n    const xk = expandKeyLE(kek);\n    if (out.length === 16) encryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = 1; j < 6; j++) {\n        for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n          const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          // A = MSB(64, B) ^ t where t = (n*j)+i\n          (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1); // out = A || out\n    }\n    xk.fill(0);\n  },\n  decrypt(kek: Uint8Array, out: Uint8Array) {\n    if (out.length - 8 >= 2 ** 32) throw new Error('ciphertext should be less than 4gb');\n    const xk = expandKeyDecLE(kek);\n    const chunks = out.length / 8 - 1; // first chunk is IV\n    if (chunks === 1) decryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n          a1 ^= byteSwap(ctr);\n          const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1);\n    }\n    xk.fill(0);\n  },\n};\n\nconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length || plaintext.length % 8 !== 0)\n        throw new Error('invalid plaintext length');\n      if (plaintext.length === 8)\n        throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n      const out = concatBytes(AESKW_IV, plaintext);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n      // 24 because should have at least two block (1 iv + 2).\n      // Replace with 16 to enable '8-byte keys'\n      if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n        throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      AESW.decrypt(kek, out);\n      if (!equalBytes(out.subarray(0, 8), AESKW_IV)) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8);\n    },\n  })\n);\n\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\n\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length) throw new Error('invalid plaintext length');\n      const padded = Math.ceil(plaintext.length / 8) * 8;\n      const out = new Uint8Array(8 + padded);\n      out.set(plaintext, 8);\n      const out32 = u32(out);\n      out32[0] = AESKWP_IV;\n      out32[1] = byteSwap(plaintext.length);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // 16 because should have at least one block\n      if (ciphertext.length < 16) throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      const o32 = u32(out);\n      AESW.decrypt(kek, out);\n      const len = byteSwap(o32[1]) >>> 0;\n      const padded = Math.ceil(len / 8) * 8;\n      if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n        throw new Error('integrity check failed');\n      for (let i = len; i < padded; i++)\n        if (out[8 + i] !== 0) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8, 8 + len);\n    },\n  })\n);\n\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe: {\n  expandKeyLE: typeof expandKeyLE;\n  expandKeyDecLE: typeof expandKeyDecLE;\n  encrypt: typeof encrypt;\n  decrypt: typeof decrypt;\n  encryptBlock: typeof encryptBlock;\n  decryptBlock: typeof decryptBlock;\n  ctrCounter: typeof ctrCounter;\n  ctr32: typeof ctr32;\n} = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32,\n};\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * WebCrypto-based AES gcm/ctr/cbc, `managedNonce` and `randomBytes`.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * node.js versions earlier than v19 don't declare it in global scope.\n * For node.js, package.js on#exports field mapping rewrites import\n * from `crypto` to `cryptoNode`, which imports native module.\n * Makes the utils un-importable in browsers without a bundler.\n * Once node.js 18 is deprecated, we can just drop the import.\n * @module\n */\n// Use full path so that Node.js can rewrite it to `cryptoNode.js`.\nimport { crypto } from '@noble/ciphers/crypto';\nimport { abytes, anumber } from './_assert.js';\nimport { type AsyncCipher, type Cipher, concatBytes } from './utils.js';\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n\nexport function getWebcryptoSubtle(): any {\n  if (crypto && typeof crypto.subtle === 'object' && crypto.subtle != null) return crypto.subtle;\n  throw new Error('crypto.subtle must be defined');\n}\n\ntype RemoveNonceInner<T extends any[], Ret> = ((...args: T) => Ret) extends (\n  arg0: any,\n  arg1: any,\n  ...rest: infer R\n) => any\n  ? (key: Uint8Array, ...args: R) => Ret\n  : never;\n\ntype RemoveNonce<T extends (...args: any) => any> = RemoveNonceInner<Parameters<T>, ReturnType<T>>;\ntype CipherWithNonce = ((key: Uint8Array, nonce: Uint8Array, ...args: any[]) => Cipher) & {\n  nonceLength: number;\n};\n\n/**\n * Uses CSPRG for nonce, nonce injected in ciphertext.\n * @example\n * const gcm = managedNonce(aes.gcm);\n * const ciphr = gcm(key).encrypt(data);\n * const plain = gcm(key).decrypt(ciph);\n */\nexport function managedNonce<T extends CipherWithNonce>(fn: T): RemoveNonce<T> {\n  const { nonceLength } = fn;\n  anumber(nonceLength);\n  return ((key: Uint8Array, ...args: any[]): any => ({\n    encrypt(plaintext: Uint8Array, ...argsEnc: any[]) {\n      const nonce = randomBytes(nonceLength);\n      const ciphertext = (fn(key, nonce, ...args).encrypt as any)(plaintext, ...argsEnc);\n      const out = concatBytes(nonce, ciphertext);\n      ciphertext.fill(0);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array, ...argsDec: any[]) {\n      const nonce = ciphertext.subarray(0, nonceLength);\n      const data = ciphertext.subarray(nonceLength);\n      return (fn(key, nonce, ...args).decrypt as any)(data, ...argsDec);\n    },\n  })) as RemoveNonce<T>;\n}\n\n// Overridable\n// @TODO\nexport const utils: {\n  encrypt: (key: Uint8Array, ...all: any[]) => Promise<Uint8Array>;\n  decrypt: (key: Uint8Array, ...all: any[]) => Promise<Uint8Array>;\n} = {\n  async encrypt(\n    key: Uint8Array,\n    keyParams: any,\n    cryptParams: any,\n    plaintext: Uint8Array\n  ): Promise<Uint8Array> {\n    const cr = getWebcryptoSubtle();\n    const iKey = await cr.importKey('raw', key, keyParams, true, ['encrypt']);\n    const ciphertext = await cr.encrypt(cryptParams, iKey, plaintext);\n    return new Uint8Array(ciphertext);\n  },\n  async decrypt(\n    key: Uint8Array,\n    keyParams: any,\n    cryptParams: any,\n    ciphertext: Uint8Array\n  ): Promise<Uint8Array> {\n    const cr = getWebcryptoSubtle();\n    const iKey = await cr.importKey('raw', key, keyParams, true, ['decrypt']);\n    const plaintext = await cr.decrypt(cryptParams, iKey, ciphertext);\n    return new Uint8Array(plaintext);\n  },\n};\n\nconst mode = {\n  CBC: 'AES-CBC',\n  CTR: 'AES-CTR',\n  GCM: 'AES-GCM',\n} as const;\ntype BlockMode = (typeof mode)[keyof typeof mode];\n\nfunction getCryptParams(algo: BlockMode, nonce: Uint8Array, AAD?: Uint8Array) {\n  if (algo === mode.CBC) return { name: mode.CBC, iv: nonce };\n  if (algo === mode.CTR) return { name: mode.CTR, counter: nonce, length: 64 };\n  if (algo === mode.GCM) {\n    if (AAD) return { name: mode.GCM, iv: nonce, additionalData: AAD };\n    else return { name: mode.GCM, iv: nonce };\n  }\n\n  throw new Error('unknown aes block mode');\n}\n\nfunction generate(algo: BlockMode) {\n  return (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): AsyncCipher => {\n    abytes(key);\n    abytes(nonce);\n    const keyParams = { name: algo, length: key.length * 8 };\n    const cryptParams = getCryptParams(algo, nonce, AAD);\n    let consumed = false;\n    return {\n      // keyLength,\n      encrypt(plaintext: Uint8Array) {\n        abytes(plaintext);\n        if (consumed) throw new Error('Cannot encrypt() twice with same key / nonce');\n        consumed = true;\n        return utils.encrypt(key, keyParams, cryptParams, plaintext);\n      },\n      decrypt(ciphertext: Uint8Array) {\n        abytes(ciphertext);\n        return utils.decrypt(key, keyParams, cryptParams, ciphertext);\n      },\n    };\n  };\n}\n\n/** AES-CBC, native webcrypto version */\nexport const cbc: (key: Uint8Array, iv: Uint8Array) => AsyncCipher = /* @__PURE__ */ (() =>\n  generate(mode.CBC))();\n/** AES-CTR, native webcrypto version */\nexport const ctr: (key: Uint8Array, nonce: Uint8Array) => AsyncCipher = /* @__PURE__ */ (() =>\n  generate(mode.CTR))();\n/** AES-GCM, native webcrypto version */\nexport const gcm: (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => AsyncCipher =\n  /* @__PURE__ */ (() => generate(mode.GCM))();\n\n// // Type tests\n// import { siv, gcm, ctr, ecb, cbc } from '../aes.js';\n// import { xsalsa20poly1305 } from '../salsa.js';\n// import { chacha20poly1305, xchacha20poly1305 } from '../chacha.js';\n\n// const wsiv = managedNonce(siv);\n// const wgcm = managedNonce(gcm);\n// const wctr = managedNonce(ctr);\n// const wcbc = managedNonce(cbc);\n// const wsalsapoly = managedNonce(xsalsa20poly1305);\n// const wchacha = managedNonce(chacha20poly1305);\n// const wxchacha = managedNonce(xchacha20poly1305);\n\n// // should fail\n// const wcbc2 = managedNonce(managedNonce(cbc));\n// const wctr = managedNonce(ctr);\n", "let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000; // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tif (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(key, read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tif (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tif (!structure) throw new Error('Structure is required in record definition');\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();\n\tif (key == null) return key + '';\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + (value << BigInt(8))\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet startingPosition = position\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) {// there is a cycle, so we have to assign properties to original target\n\t\tif (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n\t\t\t// this means that the returned target does not match the targetProperties, so we need rerun the read to\n\t\t\t// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n\t\t\t// target\n\t\t\t// reset the position so that the read can be repeated\n\t\t\tposition = startingPosition\n\t\t\t// the returned instance is our new target for references\n\t\t\ttarget = targetProperties\n\t\t\treferenceMap.set(id, { target })\n\t\t\ttargetProperties = read()\n\t\t}\n\t\treturn Object.assign(target, targetProperties)\n\t}\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n\tif (limits.maxMapSize) maxMapSize = limits.maxMapSize;\n\tif (limits.maxArraySize) maxArraySize = limits.maxArraySize;\n\tif (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize;\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n", "import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as a plain object\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value >= BigInt(0))\n\t\t\t\t\t\t\ttarget[position++] = 0xc2 // tag 2\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc3 // tag 2\n\t\t\t\t\t\t\tvalue = BigInt(-1) - value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\twhile (value) {\n\t\t\t\t\t\t\tbytes.push(Number(value & BigInt(0xff)));\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, skipValues) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, true); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator] && !object.buffer) { // iterator, but exclude typed arrays\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n", "import {\n  ed25519,\n  x25519,\n  edwardsToMontgomeryPub,\n  edwardsToMontgomeryPriv,\n} from \"@noble/curves/ed25519\";\nimport { ripemd160 } from \"@noble/hashes/ripemd160\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { hkdf } from \"@noble/hashes/hkdf\";\n//import { bytesToHex, bytesToBase64, base64ToBytes } from '@noble/hashes/utils';\n//import { bytesToHex, bytesToBase64 } from '@noble/hashes/utils';\nimport { bytesToHex } from \"@noble/hashes/utils\"; // Only import what exists\nimport { siv } from \"@noble/ciphers/aes\";\n// utf8ToBytes might not be needed if using TextEncoder directly\n// import { utf8ToBytes } from '@noble/ciphers/utils';\nimport { randomBytes } from \"@noble/ciphers/webcrypto\";\nimport { decode, encode } from \"cbor-x\"; // Assuming cbor2 is browser-compatible like cbor-x\n\n// --- TextEncoder/Decoder are usually global in modern JS (Node >= 11, Browsers) ---\n// If needed for older envs, import from 'util' in Node\n// const { TextEncoder, TextDecoder } = require('util');\n\n// --- Helper Functions ---\n\n/**\n * Encodes a Uint8Array into a Base64 string.\n * Uses 'btoa' which is available in browsers and Node.js >= 16.\n * @param {Uint8Array} bytes - The bytes to encode.\n * @returns {string} - The Base64 encoded string.\n */\nfunction bytesToBase64(bytes) {\n  // Convert bytes to a string of characters with char codes matching byte values\n  let binaryString = \"\";\n  bytes.forEach((byte) => {\n    binaryString += String.fromCharCode(byte);\n  });\n  // Encode the binary string\n  try {\n    return btoa(binaryString);\n  } catch (e) {\n    throw new Error(`Failed to encode bytes to base64: ${e.message}`);\n  }\n}\n\n/**\n * Decodes a Base64 string into a Uint8Array.\n * Uses 'atob' which is available in browsers and Node.js >= 16.\n * @param {string} base64 - The Base64 encoded string.\n * @returns {Uint8Array} - The decoded bytes.\n */\nfunction base64ToBytes(base64) {\n  try {\n    const binString = atob(base64);\n    // Convert binary string characters to byte values\n    return Uint8Array.from(binString, (m) => m.codePointAt(0));\n  } catch (e) {\n    // Handle potential errors like invalid characters in base64 string\n    throw new Error(`Failed to decode base64 string: ${e.message}`);\n  }\n}\n\nconst assertType = (variableObj, expectedType) => {\n  const [variableName, variable] = Object.entries(variableObj)[0];\n  const actualType = typeof variable;\n  const constructorName = variable?.constructor?.name;\n\n  if (expectedType === \"string\") {\n    if (actualType !== \"string\") {\n      throw new Error(\n        `${variableName} [${actualType}] is not an instance of [string].`,\n      );\n    }\n  } else if (expectedType === \"boolean\") {\n    if (actualType !== \"boolean\") {\n      throw new Error(\n        `${variableName} [${actualType}] is not an instance of [boolean].`,\n      );\n    }\n  } else if (expectedType === Uint8Array) {\n    if (!(variable instanceof Uint8Array)) {\n      throw new Error(\n        `${variableName} [${constructorName || actualType}] is not an instance of [Uint8Array].`,\n      );\n    }\n  } else {\n    // Assuming expectedType is a Class constructor\n    if (!(variable instanceof expectedType)) {\n      throw new Error(\n        `${variableName} [${constructorName || actualType}] is not an instance of [${expectedType.name}].`,\n      );\n    }\n  }\n};\n\n// --- ECIES Core Logic ---\n\n// Use HKDF-SHA256 to derive AES key (32 bytes)\nfunction deriveAesKey(sharedSecret) {\n  // Salt should ideally be random per-encryption, but for simplicity using empty here.\n  // Consider adding the ephemeral public key or nonce as salt/info if needed.\n  // 'info' distinguishes the key's purpose.\n  const info = new TextEncoder().encode(\"suite25519-aes-key\");\n  return hkdf(sha256, sharedSecret, undefined, info, 32); // Derive 32 bytes (256 bits)\n}\n\nfunction eciesEncrypt(receiverPublicKeyEd, messageUint8Array) {\n  assertType({ receiverPublicKeyEd }, Uint8Array);\n  assertType({ messageUint8Array }, Uint8Array);\n  try {\n    const receiverPublicKeyX = edwardsToMontgomeryPub(receiverPublicKeyEd);\n\n    const ephemeralPrivateKeyX = x25519.utils.randomPrivateKey();\n    const ephemeralPublicKeyX = x25519.getPublicKey(ephemeralPrivateKeyX);\n\n    const sharedSecret = x25519.getSharedSecret(\n      ephemeralPrivateKeyX,\n      receiverPublicKeyX,\n    );\n    const aesKey = deriveAesKey(sharedSecret);\n\n    // Generate a random nonce for AES-SIV\n    // 16 bytes is generally recommended for SIV nonces if used as such.\n    // If the second arg to siv() is *Associated Data*, 12 bytes might be fine.\n    // Let's stick to 16 for safety if treating as a nonce. Check noble docs if it's AD.\n    const nonce = randomBytes(12);\n\n    // Pass nonce as associated data/nonce based on noble/ciphers convention\n    // Assuming here it's used like a nonce or primary AD.\n    const aes = siv(aesKey, nonce);\n    const ciphertext = aes.encrypt(messageUint8Array);\n\n    // Return components as Uint8Arrays\n    return { C: ciphertext, P_e: ephemeralPublicKeyX, N: nonce };\n  } catch (error) {\n    throw new Error(`eciesEncrypt failed: ${error?.message}`);\n  }\n}\n\nfunction eciesDecrypt(\n  receiverPrivateKeyEd,\n  ephemeralPublicKeyX,\n  nonce,\n  ciphertext,\n) {\n  assertType({ receiverPrivateKeyEd }, Uint8Array);\n  assertType({ ephemeralPublicKeyX }, Uint8Array);\n  assertType({ nonce }, Uint8Array);\n  assertType({ ciphertext }, Uint8Array);\n  try {\n    const receiverPrivateKeyX = edwardsToMontgomeryPriv(receiverPrivateKeyEd);\n    const sharedSecret = x25519.getSharedSecret(\n      receiverPrivateKeyX,\n      ephemeralPublicKeyX,\n    );\n    const aesKey = deriveAesKey(sharedSecret);\n\n    const aes = siv(aesKey, nonce);\n    let plaintext;\n    try {\n      plaintext = aes.decrypt(ciphertext);\n    } catch (error) {\n      // Log the specific Noble library error\n      console.error(\"AES-SIV decryption failed:\", error);\n      throw new Error(\n        \"Decryption failed (authentication tag mismatch or other error)\",\n      );\n    }\n    return plaintext; // Returns Uint8Array\n  } catch (error) {\n    // Catch errors from key conversion/derivation\n    throw new Error(`eciesDecrypt failed: ${error?.message}`);\n  }\n}\n\n// --- Data Classes (Simplified) ---\n\n// Base class just holds Uint8Array data\nclass BinaryData {\n  constructor(data) {\n    assertType({ data }, Uint8Array);\n    this.data = data;\n  }\n\n  toBinary() {\n    return this.data;\n  }\n\n  // Example: Base64 encode the raw binary data\n  toBase64() {\n    return bytesToBase64(this.data);\n  }\n\n  // Example: Create from Base64 encoded raw binary data\n  static fromBase64(base64Data, ClassType = BinaryData) {\n    assertType({ base64Data }, \"string\");\n    try {\n      const data = base64ToBytes(base64Data);\n      return new ClassType(data);\n    } catch (e) {\n      throw new Error(\n        `Failed to decode base64 for ${ClassType.name}: ${e.message}`,\n      );\n    }\n  }\n}\n\n// Specific data types inherit but add little functionality here\n// Could add validation (e.g., length checks) if needed\nclass Signature extends BinaryData {}\n\n// Message class handles string conversion\nexport class Message extends BinaryData {\n  constructor(data) {\n    let binaryData;\n    if (data instanceof Uint8Array) {\n      binaryData = data;\n    } else if (typeof data === \"string\") {\n      binaryData = new TextEncoder().encode(data);\n    } else {\n      let dataType = typeof data;\n      if (data && typeof data === \"object\") {\n        dataType = data.constructor?.name || \"Object\";\n      }\n      throw new Error(\n        `Invalid data type for Message constructor: Expected string or Uint8Array, got ${dataType}`,\n      );\n    }\n    super(binaryData); // Call BinaryData constructor with Uint8Array\n  }\n\n  // Static method to create Message from random bytes\n  static randomBytes(length = 32) {\n    // Default length, e.g., 32 bytes\n    return new Message(randomBytes(length));\n  }\n\n  // Convert internal Uint8Array data back to string (assumes UTF-8)\n  toString() {\n    try {\n      return new TextDecoder().decode(this.data);\n    } catch (e) {\n      // Handle potential decoding errors if data isn't valid UTF-8\n      console.error(\"Failed to decode message data as UTF-8:\", e);\n      // Return hex as fallback? Or throw?\n      return bytesToHex(this.data);\n    }\n  }\n}\n\n// --- Key Classes ---\n\nexport class PrivateKey extends BinaryData {\n  // No static objectIdentifier needed if not using old envelope logic\n\n  // Creates a new random private key\n  static randomPrivateKey() {\n    return new PrivateKey(ed25519.utils.randomPrivateKey());\n  }\n\n  // Derives the corresponding public key\n  get publicKey() {\n    const publicKeyData = ed25519.getPublicKey(this.data);\n    return new PublicKey(publicKeyData);\n  }\n\n  // Decrypts a CBOR-encoded ECIES payload\n  decrypt(encryptedPayload) {\n    assertType({ encryptedPayload }, Uint8Array);\n    const { C, P_e, N } = decode(encryptedPayload); // Decodes CBOR to object\n    // Ensure decoded components are Uint8Array before passing to eciesDecrypt\n    assertType({ C }, Uint8Array);\n    assertType({ P_e }, Uint8Array);\n    assertType({ N }, Uint8Array);\n    const plaintext = eciesDecrypt(this.data, P_e, N, C);\n    return new Message(plaintext); // Return as Message object\n  }\n\n  // Signs a message (string or Uint8Array)\n  sign(messageData) {\n    const message =\n      messageData instanceof Message ? messageData : new Message(messageData);\n    const sigData = ed25519.sign(message.toBinary(), this.data);\n    return new Signature(sigData); // Return Signature object\n  }\n\n  // Export raw key as Base64\n  exportAsBase64() {\n    return this.toBase64();\n  }\n\n  // Import from Base64 encoded raw key\n  static importFromBase64(base64Key) {\n    return BinaryData.fromBase64(base64Key, PrivateKey);\n  }\n}\n\nexport class PublicKey extends BinaryData {\n  // No static objectIdentifier needed\n\n  // Calculates RIPEMD-160 hash of the public key (often used for addresses)\n  get id() {\n    return bytesToHex(ripemd160(this.data));\n  }\n\n  // Verifies a signature against provided data\n  verify(messageData, signature) {\n    const message =\n      messageData instanceof Message ? messageData : new Message(messageData);\n    assertType({ signature }, Signature);\n\n    let valid = false;\n    try {\n      valid = ed25519.verify(\n        signature.toBinary(),\n        message.toBinary(),\n        this.data,\n        { zip215: false },\n      ); // RFC8032 / FIPS 186-5\n    } catch (error) {\n      // verification can throw on invalid points etc.\n      console.error(\"Verification error:\", error);\n      return false; // Treat verification errors as invalid signature\n    }\n\n    if (!valid) {\n      // Optional: throw new Error('Signature invalid');\n      return false; // Typically return false for invalid signature\n    } else {\n      return true;\n    }\n  }\n\n  // Encrypts data for this public key\n  encrypt(messageData) {\n    const message =\n      messageData instanceof Message ? messageData : new Message(messageData);\n    const cipherObject = eciesEncrypt(this.data, message.toBinary());\n    // Return the CBOR-encoded payload directly\n    return encode(cipherObject); // Returns Uint8Array\n  }\n\n  // Export raw key as Base64\n  exportAsBase64() {\n    return this.toBase64();\n  }\n\n  // Import from Base64 encoded raw key\n  static importFromBase64(base64Key) {\n    return BinaryData.fromBase64(base64Key, PublicKey);\n  }\n}\n\n// --- High-Level API Functions ---\n\n/**\n * Signs a message and returns a CBOR-encoded structure.\n * @param {string | Uint8Array | Message} plainMessage - The message to sign.\n * @param {PrivateKey} signingPrivateKey - The private key for signing.\n * @param {boolean} [includeMessage=false] - Whether to include the original message in the output.\n * @param {boolean} [includeSenderPublicKey=false] - Whether to include the sender's public key in the output.\n * @returns {Uint8Array} - CBOR-encoded signature structure.\n */\nexport const signMessage = (\n  plainMessage,\n  signingPrivateKey,\n  includeMessage = false,\n  includeSenderPublicKey = false,\n) => {\n  assertType({ signingPrivateKey }, PrivateKey);\n  assertType({ includeMessage }, \"boolean\");\n  assertType({ includeSenderPublicKey }, \"boolean\");\n\n  const message =\n    plainMessage instanceof Message ? plainMessage : new Message(plainMessage);\n  const messageBinary = message.toBinary(); // Ensure we get Uint8Array\n\n  const sig = ed25519.sign(messageBinary, signingPrivateKey.toBinary());\n\n  const result = { sig }; // Always include signature\n\n  if (includeMessage) {\n    result.m = messageBinary; // Add original message (Uint8Array)\n  }\n  if (includeSenderPublicKey) {\n    result.P = signingPrivateKey.publicKey.toBinary(); // Add public key (Uint8Array)\n  }\n\n  return encode(result); // Encode the result object, returns Uint8Array\n};\n\n/**\n * Verifies a signed message payload.\n * @param {Uint8Array} signedPayload - The CBOR-encoded signed message structure.\n * @param {PublicKey} senderPublicKey - The expected public key of the sender.\n * @returns {Uint8Array | null} - The original message (Uint8Array) if verification succeeds and message was included, null otherwise.\n * @throws {Error} If signature is invalid, public key mismatch, or decoding fails.\n */\nexport const verifyMessage = (signedPayload, senderPublicKey) => {\n  assertType({ signedPayload }, Uint8Array);\n  assertType({ senderPublicKey }, PublicKey);\n\n  const decoded = decode(signedPayload); // Decode the CBOR payload\n  const { sig, m, P } = decoded;\n\n  // Basic structure check\n  if (!sig || !(sig instanceof Uint8Array)) {\n    throw new Error(\"Invalid signed payload: Missing or invalid signature.\");\n  }\n  if (m !== undefined && !(m instanceof Uint8Array)) {\n    throw new Error(\n      'Invalid signed payload: Included message \"m\" is not Uint8Array.',\n    );\n  }\n  if (P !== undefined && !(P instanceof Uint8Array)) {\n    throw new Error(\n      'Invalid signed payload: Included public key \"P\" is not Uint8Array.',\n    );\n  }\n\n  // If Public Key is included in payload, verify it matches the expected one\n  if (P) {\n    const includedPublicKey = new PublicKey(P);\n    if (includedPublicKey.id !== senderPublicKey.id) {\n      throw new Error(\n        \"Verification failed: Included public key 'P' does not match expected senderPublicKey.\",\n      );\n    }\n  }\n\n  // Determine the message to verify (either included 'm' or external 'plainMessage' if this function were different)\n  // This version requires 'm' to be present for verification as written.\n  if (m === undefined) {\n    throw new Error(\n      \"Verification failed: Message 'm' not included in the signed payload.\",\n    );\n    // Or adapt to accept plainMessage separately if needed: verify(sig, plainMessage, senderPublicKey)\n  }\n\n  const signature = new Signature(sig);\n  const message = new Message(m); // Reconstruct Message object for verification method\n\n  // Perform the actual verification\n  if (!senderPublicKey.verify(message, signature)) {\n    throw new Error(\"Verification failed: Invalid signature.\");\n  }\n\n  // Verification successful\n  return m; // Return the verified message content (Uint8Array)\n};\n\n/**\n * Encrypts a message for a recipient.\n * @param {string | Uint8Array | Message} plainMessage - The message to encrypt.\n * @param {PublicKey} recipientPublicKey - The public key of the recipient.\n * @returns {Uint8Array} - CBOR-encoded ECIES ciphertext structure {C, P_e, N}.\n */\nexport const encryptMessage = (plainMessage, recipientPublicKey) => {\n  assertType({ recipientPublicKey }, PublicKey);\n\n  const message =\n    plainMessage instanceof Message ? plainMessage : new Message(plainMessage);\n  const messageBinary = message.toBinary(); // Get Uint8Array\n\n  const cipherObject = eciesEncrypt(\n    recipientPublicKey.toBinary(),\n    messageBinary,\n  );\n\n  return encode(cipherObject); // Encode the {C, P_e, N} object, returns Uint8Array\n};\n\n/**\n * Decrypts an ECIES payload.\n * @param {Uint8Array} encryptedPayload - The CBOR-encoded ECIES structure {C, P_e, N}.\n * @param {PrivateKey} recipientPrivateKey - The private key of the recipient.\n * @returns {Uint8Array} - The decrypted plaintext message (Uint8Array).\n * @throws {Error} If decryption or decoding fails.\n */\nexport const decryptMessage = (encryptedPayload, recipientPrivateKey) => {\n  assertType({ encryptedPayload }, Uint8Array);\n  assertType({ recipientPrivateKey }, PrivateKey);\n\n  const { C, P_e, N } = decode(encryptedPayload); // Decode CBOR\n\n  // Validate decoded types\n  if (\n    !(C instanceof Uint8Array) ||\n    !(P_e instanceof Uint8Array) ||\n    !(N instanceof Uint8Array)\n  ) {\n    throw new Error(\"Invalid encrypted payload structure after CBOR decoding.\");\n  }\n\n  const messageBinary = eciesDecrypt(recipientPrivateKey.toBinary(), P_e, N, C);\n\n  return messageBinary; // Return raw Uint8Array\n};\n\n/**\n * Signs and then encrypts a message.\n * @param {string | Uint8Array | Message} plainMessage - The message to sign and encrypt.\n * @param {PrivateKey} signingPrivateKey - The sender's private key.\n * @param {PublicKey} recipientPublicKey - The recipient's public key.\n * @param {boolean} [includeSenderPublicKey=true] - Whether to include sender's public key in the signed part. Recommended.\n * @returns {Uint8Array} - CBOR-encoded ECIES structure containing the signed message payload.\n */\nexport const signAndEncryptMessage = (\n  plainMessage,\n  signingPrivateKey,\n  recipientPublicKey,\n  includeSenderPublicKey = true,\n) => {\n  assertType({ signingPrivateKey }, PrivateKey);\n  assertType({ recipientPublicKey }, PublicKey);\n  assertType({ includeSenderPublicKey }, \"boolean\");\n\n  // 1. Sign the message (including message and optionally public key) -> CBOR payload (Uint8Array)\n  // It's generally good to include the public key here so the recipient knows who signed it.\n  const signedPayload = signMessage(\n    plainMessage,\n    signingPrivateKey,\n    true,\n    includeSenderPublicKey,\n  );\n\n  // 2. Encrypt the *entire signed payload* for the recipient\n  const encryptedSignedPayload = encryptMessage(\n    signedPayload,\n    recipientPublicKey,\n  ); // encryptMessage handles CBOR encoding\n\n  return encryptedSignedPayload; // Returns the final CBOR-encoded Uint8Array {C, P_e, N}\n};\n\n/**\n * Decrypts and then verifies a message.\n * @param {Uint8Array} encryptedSignedPayload - The CBOR-encoded ECIES payload from signAndEncryptMessage.\n * @param {PrivateKey} recipientPrivateKey - The recipient's private key (for decryption).\n * @param {PublicKey} senderPublicKey - The expected sender's public key (for verification).\n * @returns {Uint8Array} - The original, verified message plaintext (Uint8Array).\n * @throws {Error} If decryption, decoding, or verification fails.\n */\nexport const decryptAndVerifyMessage = (\n  encryptedSignedPayload,\n  recipientPrivateKey,\n  senderPublicKey,\n) => {\n  assertType({ encryptedSignedPayload }, Uint8Array);\n  assertType({ recipientPrivateKey }, PrivateKey);\n  assertType({ senderPublicKey }, PublicKey);\n\n  // 1. Decrypt the outer payload to get the inner signed payload\n  const signedPayload = decryptMessage(\n    encryptedSignedPayload,\n    recipientPrivateKey,\n  ); // Returns Uint8Array (inner CBOR)\n\n  // 2. Verify the inner signed payload\n  // verifyMessage handles CBOR decoding and signature verification\n  const originalMessage = verifyMessage(signedPayload, senderPublicKey); // Returns original message Uint8Array if valid\n\n  return originalMessage; // Return the verified original message\n};\n"],
  "mappings": "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",
  "names": ["anumber", "n", "isBytes", "a", "abytes", "b", "lengths", "ahash", "h", "aexists", "instance", "checkFinished", "aoutput", "out", "min", "crypto", "createView", "arr", "rotr", "word", "shift", "rotl", "hasHexBuiltin", "hexes", "_", "i", "bytesToHex", "bytes", "abytes", "hex", "utf8ToBytes", "str", "toBytes", "data", "abytes", "Hash", "wrapConstructor", "hashCons", "hashC", "msg", "toBytes", "tmp", "randomBytes", "bytesLength", "crypto", "setBigUint64", "view", "byteOffset", "value", "isLE", "_32n", "_u32_max", "wh", "wl", "h", "Chi", "a", "b", "c", "Maj", "HashMD", "Hash", "blockLen", "outputLen", "padOffset", "createView", "data", "aexists", "buffer", "toBytes", "len", "pos", "take", "dataView", "out", "aoutput", "i", "oview", "outLen", "state", "res", "to", "length", "finished", "destroyed", "SHA256_K", "SHA256_IV", "SHA256_W", "SHA256", "HashMD", "outputLen", "A", "B", "C", "D", "E", "F", "G", "H", "view", "offset", "i", "W15", "W2", "s0", "rotr", "s1", "sigma1", "T1", "Chi", "T2", "Maj", "sha256", "wrapConstructor", "SHA256", "U32_MASK64", "_32n", "fromBig", "n", "le", "split", "lst", "Ah", "Al", "i", "h", "l", "toBig", "shrSH", "_l", "s", "shrSL", "rotrSH", "rotrSL", "rotrBH", "rotrBL", "rotr32H", "_h", "rotr32L", "rotlSH", "rotlSL", "rotlBH", "rotlBL", "add", "Bh", "Bl", "add3L", "Cl", "add3H", "low", "Ch", "add4L", "Dl", "add4H", "Dh", "add5L", "El", "add5H", "Eh", "u64", "fromBig", "split", "toBig", "shrSH", "shrSL", "rotrSH", "rotrSL", "rotrBH", "rotrBL", "rotr32H", "rotr32L", "rotlSH", "rotlSL", "rotlBH", "rotlBL", "add", "add3L", "add3H", "add4L", "add4H", "add5H", "add5L", "u64_default", "SHA512_Kh", "SHA512_Kl", "u64_default", "n", "SHA512_W_H", "SHA512_W_L", "SHA512", "HashMD", "outputLen", "Ah", "Al", "Bh", "Bl", "Ch", "Cl", "Dh", "Dl", "Eh", "El", "Fh", "Fl", "Gh", "Gl", "Hh", "Hl", "view", "offset", "i", "W15h", "W15l", "s0h", "s0l", "W2h", "W2l", "s1h", "s1l", "SUMl", "SUMh", "sigma1h", "sigma1l", "CHIh", "CHIl", "T1ll", "T1h", "T1l", "sigma0h", "sigma0l", "MAJh", "MAJl", "All", "sha512", "wrapConstructor", "SHA512", "_0n", "_1n", "isBytes", "a", "abytes", "item", "abool", "title", "value", "hexToNumber", "hex", "_0n", "hasHexBuiltin", "hexes", "_", "i", "bytesToHex", "bytes", "abytes", "asciis", "asciiToBase16", "ch", "hexToBytes", "hl", "al", "array", "ai", "hi", "n1", "n2", "char", "bytesToNumberBE", "bytesToNumberLE", "numberToBytesBE", "n", "len", "numberToBytesLE", "ensureBytes", "title", "hex", "expectedLength", "res", "hexToBytes", "e", "isBytes", "len", "concatBytes", "arrays", "sum", "i", "a", "abytes", "pad", "isPosBig", "n", "_0n", "inRange", "min", "max", "aInRange", "title", "bitLen", "len", "_1n", "bitMask", "n", "_1n", "validatorFns", "val", "isBytes", "object", "validateObject", "validators", "optValidators", "checkField", "fieldName", "type", "isOptional", "checkVal", "memoized", "fn", "map", "arg", "args", "val", "computed", "_0n", "_1n", "_2n", "_3n", "_4n", "_5n", "_8n", "_9n", "_16n", "mod", "a", "b", "result", "pow", "num", "power", "modulo", "res", "pow2", "x", "invert", "number", "y", "u", "v", "q", "r", "m", "n", "tonelliShanks", "P", "legendreC", "Q", "S", "Z", "p1div4", "Fp", "root", "Q1div2", "g", "t2", "ge", "FpSqrt", "c1", "n2", "nv", "i", "isNegativeLE", "FIELD_FIELDS", "validateField", "field", "initial", "opts", "map", "val", "validateObject", "FpPow", "f", "p", "d", "FpInvertBatch", "nums", "tmp", "lastMultiplied", "acc", "inverted", "nLength", "n", "nBitLength", "_nBitLength", "nByteLength", "Field", "ORDER", "bitLen", "isLE", "redef", "_0n", "BITS", "BYTES", "sqrtP", "f", "bitMask", "_1n", "num", "mod", "lhs", "rhs", "power", "FpPow", "invert", "FpSqrt", "lst", "FpInvertBatch", "a", "b", "c", "numberToBytesLE", "numberToBytesBE", "bytes", "bytesToNumberLE", "bytesToNumberBE", "_0n", "_1n", "constTimeNegate", "condition", "item", "neg", "validateW", "W", "bits", "calcWOpts", "scalarBits", "windows", "windowSize", "maxNumber", "mask", "bitMask", "shiftBy", "calcOffsets", "n", "window", "wOpts", "wbits", "nextN", "offsetStart", "offset", "isZero", "isNeg", "isNegF", "validateMSMPoints", "points", "c", "p", "i", "validateMSMScalars", "scalars", "field", "s", "pointPrecomputes", "pointWindowSizes", "getW", "P", "wNAF", "elm", "d", "base", "precomputes", "f", "wo", "offsetF", "acc", "transform", "comp", "prev", "pippenger", "fieldN", "zero", "bitLen", "MASK", "buckets", "lastBits", "sum", "j", "scalar", "resI", "sumI", "validateBasic", "curve", "validateField", "validateObject", "nLength", "_0n", "_1n", "_2n", "_8n", "VERIFY_DEFAULT", "validateOpts", "curve", "opts", "validateBasic", "validateObject", "twistedEdwards", "curveDef", "CURVE", "Fp", "CURVE_ORDER", "prehash", "cHash", "randomBytes", "nByteLength", "cofactor", "MASK", "modP", "Fn", "Field", "uvRatio", "u", "v", "adjustScalarBytes", "bytes", "domain", "data", "ctx", "phflag", "abool", "aCoordinate", "title", "n", "banZero", "min", "aInRange", "aextpoint", "other", "Point", "toAffineMemo", "memoized", "p", "iz", "x", "y", "z", "is0", "ax", "ay", "zz", "assertValidMemo", "a", "d", "X", "Y", "Z", "T", "X2", "Y2", "Z2", "Z4", "aX2", "left", "right", "XY", "ZT", "ex", "ey", "ez", "et", "points", "toInv", "i", "scalars", "pippenger", "windowSize", "wnaf", "X1", "Y1", "Z1", "X1Z2", "X2Z1", "Y1Z2", "Y2Z1", "A", "B", "C", "D", "x1y1", "E", "G", "F", "H", "X3", "Y3", "T3", "Z3", "T1", "T2", "scalar", "f", "acc", "I", "hex", "zip215", "len", "ensureBytes", "normed", "lastByte", "bytesToNumberLE", "max", "y2", "isValid", "isXOdd", "isLastByteOdd", "privKey", "getPrivateScalar", "numberToBytesLE", "bytesToHex", "wNAF", "modN", "mod", "modN_LE", "hash", "key", "hashed", "head", "prefix", "getExtendedPublicKey", "point", "pointBytes", "getPublicKey", "hashDomainToScalar", "context", "msgs", "msg", "concatBytes", "sign", "options", "r", "R", "k", "s", "res", "verifyOpts", "verify", "sig", "publicKey", "SB", "_0n", "_1n", "validateOpts", "curve", "validateObject", "montgomery", "curveDef", "CURVE", "P", "modP", "n", "mod", "montgomeryBits", "montgomeryBytes", "fieldLen", "adjustScalarBytes", "bytes", "powPminus2", "x", "pow", "cswap", "swap", "x_2", "x_3", "dummy", "a24", "montgomeryLadder", "u", "scalar", "aInRange", "k", "x_1", "z_2", "z_3", "sw", "t", "k_t", "A", "AA", "B", "BB", "E", "C", "D", "DA", "CB", "dacb", "da_cb", "z2", "encodeUCoordinate", "numberToBytesLE", "decodeUCoordinate", "uEnc", "ensureBytes", "bytesToNumberLE", "decodeScalar", "len", "valid", "scalarMult", "pointU", "_scalar", "pu", "GuBytes", "scalarMultBase", "privateKey", "publicKey", "ED25519_P", "ED25519_SQRT_M1", "_0n", "_1n", "_2n", "_3n", "_5n", "_8n", "ed25519_pow_2_252_3", "x", "_10n", "_20n", "_40n", "_80n", "P", "b2", "b4", "pow2", "b5", "b10", "b20", "b40", "b80", "b160", "b240", "b250", "adjustScalarBytes", "bytes", "uvRatio", "u", "v", "v3", "mod", "v7", "pow", "vx2", "root1", "root2", "useRoot1", "useRoot2", "noRoot", "isNegativeLE", "Fp", "Field", "ED25519_P", "ed25519Defaults", "_8n", "sha512", "randomBytes", "adjustScalarBytes", "uvRatio", "ed25519", "twistedEdwards", "x25519", "montgomery", "ED25519_P", "x", "P", "pow_p_5_8", "b2", "ed25519_pow_2_252_3", "mod", "pow2", "_3n", "adjustScalarBytes", "randomBytes", "edwardsToMontgomeryPub", "edwardsPub", "y", "ed25519", "_1n", "Fp", "edwardsToMontgomeryPriv", "edwardsPriv", "hashed", "ed25519Defaults", "Rho", "Id", "_", "i", "Pi", "idxL", "idxR", "j", "k", "shifts", "shiftsL", "idx", "shiftsR", "Kl", "Kr", "f", "group", "x", "y", "z", "R_BUF", "RIPEMD160", "HashMD", "h0", "h1", "h2", "h3", "h4", "view", "offset", "al", "ar", "bl", "br", "cl", "cr", "dl", "dr", "el", "er", "rGroup", "hbl", "hbr", "rl", "rr", "sl", "sr", "tl", "rotl", "tr", "ripemd160", "wrapConstructor", "HMAC", "Hash", "hash", "_key", "ahash", "key", "toBytes", "blockLen", "pad", "buf", "aexists", "out", "abytes", "to", "oHash", "iHash", "finished", "destroyed", "outputLen", "hmac", "message", "extract", "hash", "ikm", "salt", "ahash", "hmac", "toBytes", "HKDF_COUNTER", "EMPTY_BUFFER", "expand", "prk", "info", "length", "anumber", "blocks", "okm", "HMAC", "HMACTmp", "T", "counter", "hkdf", "isBytes", "a", "abytes", "b", "lengths", "aexists", "instance", "checkFinished", "aoutput", "out", "abytes", "min", "u8", "arr", "u32", "createView", "isLE", "utf8ToBytes", "str", "toBytes", "data", "utf8ToBytes", "isBytes", "copyBytes", "equalBytes", "a", "b", "diff", "i", "wrapCipher", "params", "constructor", "wrappedCipher", "key", "args", "abytes", "nonce", "tagl", "cipher", "checkOutput", "fnLength", "output", "called", "data", "getOutput", "expectedLength", "out", "onlyAligned", "isAligned32", "setBigUint64", "view", "byteOffset", "value", "isLE", "_32n", "_u32_max", "wh", "wl", "h", "isAligned32", "bytes", "copyBytes", "clean", "arrays", "i", "BLOCK_SIZE", "ZEROS16", "ZEROS32", "u32", "POLY", "mul2", "s0", "s1", "s2", "s3", "hiBit", "swapLE", "n", "_toGHASHKey", "k", "carry", "i", "t", "estimateWindow", "bytes", "GHASH", "key", "expectedLength", "toBytes", "abytes", "kView", "createView", "k0", "k1", "k2", "k3", "doubles", "W", "windows", "windowSize", "items", "w", "byte", "j", "d0", "d1", "d2", "d3", "o0", "o1", "o2", "o3", "mask", "num", "bytePos", "bitPos", "bit", "e0", "e1", "e2", "e3", "data", "aexists", "b32", "blocks", "left", "clean", "elm", "out", "aoutput", "o32", "res", "Polyval", "ghKey", "copyBytes", "wrapConstructorWithKey", "hashCons", "hashC", "msg", "tmp", "ghash", "polyval", "BLOCK_SIZE", "BLOCK_SIZE32", "POLY", "mul2", "n", "mul", "a", "b", "res", "sbox", "i", "x", "box", "clean", "rotr32_8", "n", "rotl32_8", "genTtable", "sbox", "fn", "T0", "_", "j", "T1", "rotl32_8", "T2", "T3", "T01", "T23", "sbox2", "i", "idx", "tableEncoding", "s", "mul", "xPowers", "p", "i", "x", "mul2", "expandKeyLE", "key", "abytes", "len", "sbox2", "tableEncoding", "toClean", "isAligned32", "copyBytes", "k32", "u32", "Nk", "subByte", "n", "applySbox", "xk", "t", "rotr32_8", "clean", "apply0123", "T01", "T23", "s0", "s1", "s2", "s3", "applySbox", "sbox2", "encrypt", "xk", "tableEncoding", "k", "rounds", "i", "t0", "t1", "t2", "t3", "ctr32", "xk", "isLE", "nonce", "src", "dst", "abytes", "BLOCK_SIZE", "getOutput", "ctr", "c32", "u32", "view", "createView", "src32", "dst32", "ctrPos", "srcLen", "ctrNum", "s0", "s1", "s2", "s3", "encrypt", "i", "start", "BLOCK_SIZE32", "b32", "buf", "u8", "pos", "clean", "computeTag", "fn", "isLE", "key", "data", "AAD", "aadLength", "h", "num", "view", "createView", "setBigUint64", "res", "clean", "limit", "name", "min", "max", "value", "minmax", "siv", "wrapCipher", "key", "nonce", "AAD", "AAD_LIMIT", "PLAIN_LIMIT", "NONCE_LIMIT", "CIPHER_LIMIT", "abytes", "deriveKeys", "xk", "expandKeyLE", "encKey", "authKey", "toClean", "_nonce", "isAligned32", "copyBytes", "n32", "u32", "s0", "s1", "s2", "s3", "counter", "derivedKey", "d32", "i", "o0", "o1", "encrypt", "res", "clean", "_computeTag", "data", "tag", "computeTag", "polyval", "t32", "processSiv", "input", "block", "ctr32", "plaintext", "out", "ciphertext", "expectedTag", "equalBytes", "crypto", "randomBytes", "bytesLength", "crypto", "decoder", "src", "srcEnd", "position", "EMPTY_ARRAY", "LEGACY_RECORD_INLINE_ID", "RECORD_DEFINITIONS_ID", "RECORD_INLINE_ID", "BUNDLED_STRINGS_ID", "PACKED_REFERENCE_TAG_ID", "STOP_CODE", "maxArraySize", "maxMapSize", "strings", "EMPTY_ARRAY", "stringPosition", "currentDecoder", "currentStructures", "srcString", "srcStringStart", "srcStringEnd", "bundledStrings", "referenceMap", "currentExtensions", "currentExtensionRanges", "packedValues", "dataView", "restoreMapsAsObject", "defaultOptions", "sequentialMode", "inlineObjectReadThreshold", "inlineObjectReadThreshold", "Decoder", "_Decoder", "options", "k", "v", "key", "rec", "map", "res", "safeKey", "source", "end", "r", "src", "saveState", "clearSource", "defaultOptions", "srcEnd", "position", "stringPosition", "srcStringEnd", "srcString", "strings", "EMPTY_ARRAY", "bundledStrings", "dataView", "error", "currentDecoder", "packedValues", "currentStructures", "checkedRead", "forEach", "values", "lastPosition", "size", "sequentialMode", "value", "defaultDecoder", "checkedRead", "result", "read", "bundledStrings", "position", "error", "srcEnd", "currentStructures", "src", "referenceMap", "sequentialMode", "clearSource", "token", "majorType", "getFloat16", "dataView", "value", "currentDecoder", "multiplier", "mult10", "array", "i", "STOP_CODE", "maxArraySize", "key", "object", "maxMapSize", "safeKey", "restoreMapsAsObject", "map", "readBin", "srcStringEnd", "srcString", "srcStringStart", "string", "shortStringInJS", "longStringInJS", "readFixedString", "BUNDLED_STRINGS_ID", "structure", "createStructureReader", "RECORD_INLINE_ID", "length", "readJustLength", "id", "recordDefinition", "RECORD_DEFINITIONS_ID", "readBundleExt", "loadShared", "extension", "currentExtensions", "input", "currentExtensionRanges", "Tag", "packedValue", "packedValues", "getPackedValues", "validName", "readObject", "compiledReader", "inlineObjectReadThreshold", "k", "readStringJS", "readStringJS", "length", "result", "shortStringInJS", "decoder", "src", "position", "end", "units", "byte1", "byte2", "byte3", "byte4", "unit", "fromCharCode", "longStringInJS", "start", "bytes", "i", "byte", "a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "l", "m", "n", "o", "readBin", "currentDecoder", "f32Array", "u8Array", "getFloat16", "byte0", "src", "position", "byte1", "exponent", "abs", "keyCache", "Tag", "value", "tag", "currentExtensions", "dateString", "epochSec", "buffer", "i", "l", "fraction", "recordDefinition", "id", "structure", "existingStructure", "currentStructures", "createStructureReader", "LEGACY_RECORD_INLINE_ID", "data", "length", "object", "key", "safeKey", "bundledStrings", "glbl", "packedTable", "read", "src", "position", "error", "newPackedValues", "packedValues", "PACKED_REFERENCE_TAG_ID", "currentDecoder", "loadShared", "referenceMap", "startingPosition", "token", "target", "refEntry", "targetProperties", "array", "restoreMapsAsObject", "combine", "a", "b", "getPackedValues", "SHARED_DATA_TAG_ID", "currentExtensionRanges", "input", "isLittleEndianMachine", "typedArrays", "typedArrayTags", "registerTypedArray", "TypedArray", "dvMethod", "bytesPerElement", "littleEndian", "sizeShift", "dv", "elements", "ta", "method", "readBundleExt", "readJustLength", "bundlePosition", "bundleLength", "dataPosition", "readStringJS", "dataView", "sharedData", "saveState", "updatedStructures", "callback", "savedSrcEnd", "srcEnd", "savedPosition", "savedStringPosition", "stringPosition", "savedSrcStringStart", "srcStringStart", "savedSrcStringEnd", "srcStringEnd", "savedSrcString", "srcString", "savedStrings", "strings", "savedReferenceMap", "savedBundledStrings", "savedSrc", "savedStructures", "savedDecoder", "savedSequentialMode", "sequentialMode", "clearSource", "mult10", "i", "defaultDecoder", "Decoder", "decode", "decodeMultiple", "FLOAT32_OPTIONS", "textEncoder", "extensions", "extensionClasses", "Buffer", "hasNodeBuffer", "ByteArrayAllocate", "ByteArray", "MAX_STRUCTURES", "MAX_BUFFER_SIZE", "throwOnIterable", "target", "targetView", "position", "safeEnd", "bundledStrings", "MAX_BUNDLE_SIZE", "hasNonLatin", "RECORD_SYMBOL", "Encoder", "Decoder", "options", "typeBuffer", "start", "sharedStructures", "hasSharedUpdate", "structures", "referenceMap", "encodeUtf8", "ByteArray", "string", "maxBytes", "textEncoder", "encoder", "hasSharedStructures", "maxSharedStructures", "isSequential", "samplingPackedValues", "packedObjectMap", "sharedValues", "sharedPackedObjectMap", "i", "l", "recordIdsToRemove", "transitionsCount", "serializationsSinceTransitionRebuild", "value", "encodeOptions", "r", "ByteArrayAllocate", "REUSE_BUFFER_MODE", "sharedData", "sharedStructuresLength", "keys", "nextTransition", "transition", "j", "key", "packedValues", "findRepetitiveStrings", "writeArrayHeader", "valuesArray", "encode", "THROW_ON_ITERABLE", "writeBundles", "makeRoom", "serialized", "insertIds", "returnBuffer", "RESET_BUFFER_MODE", "threshold", "status", "type", "length", "packedPosition", "strLength", "extStart", "twoByte", "headerSize", "c1", "c2", "strPosition", "useFloat32", "xShifted", "mult10", "referee", "idsToInsert", "constructor", "writeObject", "entryValue", "extensions", "extensionClass", "extensionClasses", "extension", "tag", "error", "entry", "isBlob", "json", "bytes", "writeBuffer", "object", "vals", "objectOffset", "size", "skipValues", "newTransitions", "parentRecordId", "k", "recordId", "MAX_STRUCTURES", "end", "newSize", "MAX_BUFFER_SIZE", "newBuffer", "chunkThreshold", "continuedChunkThreshold", "startEncoding", "encodeObjectAsIterable", "encodeObjectAsAsyncIterable", "iterateProperties", "finalIterable", "useRecords", "writeEntityLength", "tryEncode", "restartEncoding", "restart", "encodeIterable", "encodedValue", "reader", "next", "asyncValue", "buffer", "lastVersion", "structuresCopy", "SharedData", "saveResults", "existingShared", "structure", "majorValue", "values", "version", "BlobConstructor", "packedStatus", "includeKeys", "isLittleEndianMachine", "Tag", "date", "seconds", "set", "array", "regex", "arrayBuffer", "typedArray", "hasNodeBuffer", "typedArrayEncoder", "definitions", "offset", "Buffer", "nextId", "distanceToMove", "lastEnd", "a", "b", "id", "writeStrings", "defaultEncoder", "Encoder", "encode", "encodeAsIterable", "encodeAsAsyncIterable", "NEVER", "ALWAYS", "DECIMAL_ROUND", "DECIMAL_FIT", "FLOAT32_OPTIONS", "REUSE_BUFFER_MODE", "RESET_BUFFER_MODE", "THROW_ON_ITERABLE", "bytesToBase64", "bytes", "binaryString", "byte", "e", "base64ToBytes", "base64", "binString", "m", "assertType", "variableObj", "expectedType", "variableName", "variable", "actualType", "constructorName", "deriveAesKey", "sharedSecret", "info", "hkdf", "sha256", "eciesEncrypt", "receiverPublicKeyEd", "messageUint8Array", "receiverPublicKeyX", "edwardsToMontgomeryPub", "ephemeralPrivateKeyX", "x25519", "ephemeralPublicKeyX", "aesKey", "nonce", "randomBytes", "siv", "error", "eciesDecrypt", "receiverPrivateKeyEd", "ciphertext", "receiverPrivateKeyX", "edwardsToMontgomeryPriv", "aes", "plaintext", "BinaryData", "_BinaryData", "data", "base64Data", "ClassType", "Signature", "Message", "_Message", "binaryData", "dataType", "length", "bytesToHex", "PrivateKey", "_PrivateKey", "ed25519", "publicKeyData", "PublicKey", "encryptedPayload", "C", "P_e", "N", "decode", "messageData", "message", "sigData", "base64Key", "_PublicKey", "ripemd160", "signature", "valid", "cipherObject", "encode", "signMessage", "plainMessage", "signingPrivateKey", "includeMessage", "includeSenderPublicKey", "messageBinary", "result", "verifyMessage", "signedPayload", "senderPublicKey", "decoded", "sig", "P", "encryptMessage", "recipientPublicKey", "decryptMessage", "recipientPrivateKey", "signAndEncryptMessage", "decryptAndVerifyMessage", "encryptedSignedPayload"]
}
